## CPU设计草稿

---

### 思考题

#### Q1：

​		上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

#### A1：

+ 状态存储：IM、RF、DM
+ 状态转移：NPC、ALU、CU

#### Q2：

​		现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

#### A2：

1. **IM 使用 ROM**:
	- ROM（只读存储器）通常用于存储不会改变的指令代码，因为它们是只读的，无法被程序修改。
	- 这是合理的选择，因为程序的指令通常在运行时不会被改变。
2. **DM 使用 RAM**:
	- RAM（随机存储器）用于存储数据，因为数据需要被读取和写入，可能在程序执行过程中频繁变化。
	- 这也是合理的，因为数据存储器必须支持读取和写入操作。
3. **GRF 使用寄存器**:
	- 通用寄存器用于存储程序执行的临时数据和中间结果。
	- 寄存器速度非常快，适合存储需要频繁访问的数据。
	- 这是一种合理的选择，因为GRF通常用于暂存计算的中间结果。

#### Q3：

​		在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

#### A3：

​		暂时没有，反而是我将CU拆成and_logical和or_logical

#### Q4：

​		事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

#### A4：

​		因为nop的时候,没有这条指令，所有的控制信号都是0，写不进东西，所以不需要控制

#### Q5：

​		阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

#### A5：

​		跳转指令的覆盖太少了，而且sw、lw也没实现offset和base的正负数组合。

---

### 框架分析

##### 核心思路：

+ CPU的功能是控制指令执行，过程是**取指、取数、执行（运算或从内存中取数存数）**
+ ：**取指（NPC+IM） -> 产生控制信号（CU）->  取数（GRF、DM） -> 运算（ALU） -> 内存存取操作（DM） -> 向寄存器写值操作（GRF） -> 计算Next PC值（NPC）**

---

### 具体实现

+ 所需要实现的指令：`add, sub, ori, lw, sw, beq, lui, nop`

#### 一、各部件

**1、ALU：**

+ 模块端口定义

| 信号名       | 方向 | 描述     | 备注        |
| ------------ | ---- | -------- | ----------- |
| a[31:0]      | I    | 运算数a  |             |
| b[31:0]      | I    | 运算数b  |             |
| ALUOp[3:0]   | I    | 选择信号 |             |
| result[31:0] | O    | 输出结果 |             |
| Jzero        | O    | 零标志位 | result=0置1 |

+ 实现方法

| 指令  | 方法                          |
| ----- | ----------------------------- |
| add   | 使用加法器                    |
| sub   | 使用减法器                    |
| ori   | 使用或                        |
| lw    | 计算偏移量用加法器            |
| sw    | 计算偏移量用加法器            |
| beq   | 使用比较器，利用Jzero信号反应 |
| lui   | 使用b低位补0                  |
| nop   | 无                            |
| addiu | 使用加法器                    |

+ ALUOp功能

| ALUOp | 功能                        |
| ----- | --------------------------- |
| 0000  | 实现两个数**相加**（add）   |
| 0001  | 实现两个数**做差**（sub）   |
| 0010  | 实现两个数**或运算**（ori） |
| 0011  | 实现两个数**与运算**（and） |
| 0100  | 实现B低位补零（lui）        |
|       |                             |

**2、IM：**

+ 用一个只读存储器ROM指令（指令为32位，地址位宽12，即4096条指令）
+ 其中一点设计细节：将[PC - 0x00003000]传入ROM寻指（这样PC初始值为0x00003000而ROM中直接从0x00003000储存）

**3、GRF：**

​		延用p0设计的GRF：

| 信号名     | 方向 | 描述                                                  |
| ---------- | ---- | ----------------------------------------------------- |
| clk        | I    | 时钟信号                                              |
| reset      | I    | 复位信号，32个寄存器清零<br />1：复位<br />0：无效    |
| EnRegWrite | I    | 写使能信号<br />有效时（**clk时钟下跳沿**）将数据写入 |
| RegAdd1    | I    | 将RA1地址的寄存器的数据读到RD1                        |
| RegAdd2    | I    | 将RA2地址的寄存器的数据读到RD2                        |
| WriteRegA  | I    | 将数据写入的寄存器的地址                              |
| WriteData  | I    | 写入的数据                                            |
| ReadData1  | O    | 输出RA1地址的寄存器的数据                             |
| ReadData2  | O    | 输出RA2地址的寄存器的数据                             |

**5、DM：**

+ 用一个可写入的RAM来实现
+ 多实现了按**字**、**半字**、**字节**来读写

| 信号名    | 方向 | 描述                                                         |
| --------- | ---- | ------------------------------------------------------------ |
| addr      | I    | 读或写的地址                                                 |
| writeData | I    | 写入的数                                                     |
| clk       | I    | 时钟信号                                                     |
| MemRead   | I    | 控制信号有效时addr地址选择的存储字被放在readData上           |
| MemWrite  | I    | 控制信号有效且clk下跳时，writeData写入addr地址               |
| reset     | I    | 异步复位信号                                                 |
| DMOp      | I    | 操作单位选择信号<br />00：按字（sw，lw）<br />01：按字节（sb， lb）<br />10：按半字（sh， lh） |
| ReadData  | O    | 输出读取到的内容                                             |

**6、CU：**

+ 端口定义：

| 信号名        | 方向 | 描述                                                         |
| ------------- | ---- | ------------------------------------------------------------ |
| Op            | I    |                                                              |
| func          | I    |                                                              |
| RegDst[1:0]   | O    | 00：写入Rt<br />01：写入Rd<br />10：写入\$RA                 |
| ALUSrc        | O    | 0：选项ReadData2输入ALU<br />1：选择立即数经过SignExt输入ALU |
| MemtoReg[1:0] | O    | 00：选择ALUResult输入<br />01：选择DMReadData输入<br />10：选的PC + 4输入 |
| RegWrite      | O    | 有效时可写入GRF                                              |
| MemRead       | O    | lw指令，有效时读出DM                                         |
| MemWrite      | O    | sw指令，有效时写入DM                                         |
| EXTOp         | O    | 0：零扩展<br />1：符号扩展                                   |
| ALUOp[3:0]    | O    | 传递给ALU，具体功能见ALU                                     |
| Branch[3:0]   | O    | 跳转信号类型<br />000：PC + 4<br />001：beq<br />010：j<br />011：jal<br />100：jr |
|               |      |                                                              |
|               |      |                                                              |

+ 根据RTL，打表（对应指令与控制信号）

![image-20231026000438002](C:/Users/yaobo‘s C/AppData/Roaming/Typora/typora-user-images/image-20231026000438002.png)

**7、NPC：**

+ 首先想清楚跳转的集中情况：
	+ PC = PC + 4
	+ beq跳转，需要接受ALU的Jzero信号，跳转的立即数（先扩展再左移的，考虑是否会出问题）
	+ j跳转，需要立即数
	+ jal跳转，需要额外保存PC + 4
	+ jr跳转，需要取出之前的PC + 4

| 信号名    | 方向 | 位宽 | 描述                                                         |
| --------- | ---- | ---- | ------------------------------------------------------------ |
| PC        | I    | 32   | 输入当前正在执行的指令的地址                                 |
| imm26     | I    | 26   | instr_index                                                  |
| imm16     | I    | 16   | beq跳转的offset                                              |
| RA        | I    | 32   | 储存在寄存器\$ra中的地址数据                                 |
| Branch    | I    | 3    | 跳转信号类型<br />000：PC + 4<br />001：beq<br />010：j<br />011：jal<br />100：jr |
| Jzero     | I    | 1    | beq跳转标志                                                  |
| NPC       | O    | 32   | 输出的吓一条要被执行的指令                                   |
| PC4       | O    | 32   | 输出PC + 4（用于jal）                                        |
| WriteToRA | O    | 1    | 有效时将PC + 4写入\$ra                                       |

+ 注意要将RA与\$ra连接
+ 控制信号与指令对应表格

**8、Splitter：**

+ 分成：Op、rs、rt、rd、func、imm16、imm26

**9、PC：**

+ PC寄存器放在这一模块里
+ 这里用了两个异或，实现了置位之后PC从0x00003000开始

#### 二、顶层连线

+ 按照ppt的大体框架在连线
+ 其中有很多MUX选择进入各模块的信号（选择信号又CU产生）

---

### 测试CPU

+ 按照教程写了一点测试样例，并将mars的内存和寄存器与logisim里DM和GRF进行了比对（将测试的.asm和16进制机器码打包提交）

	<img src="C:/Users/yaobo‘s C/AppData/Roaming/Typora/typora-user-images/image-20231026160545875.png" alt="image-20231026160545875" style="zoom: 80%;" />

---

### **指令集：**

| 指令  | op     | func   | RegDst | ALUScr | MemtoReg | RegWrite | MemRead | MemWrite | EXTOp | ALUop[3:0] | Branch |
| ----- | ------ | ------ | ------ | ------ | -------- | -------- | ------- | -------- | ----- | ---------- | ------ |
|       |        |        |        |        |          |          |         |          |       |            |        |
| add   | 000000 | 100000 | 01     | 0      | 00       | 1        | 0       | 0        | 0     | 0000       | 000    |
| sub   | 000000 | 100010 | 01     | 0      | 00       | 1        | 0       | 0        | 0     | 0001       | 000    |
| ori   | 001101 |        | 00     | 1      | 00       | 1        | 0       | 0        | 0     | 0010       | 000    |
| lw    | 100011 |        | 00     | 1      | 01       | 1        | 1       | 0        | 1     | 0000       | 000    |
| sw    | 101011 |        | 00     | 1      | 00       | 0        | 0       | 1        | 1     | 0000       | 000    |
| beq   | 000100 |        | 00     | 0      | 00       | 0        | 0       | 0        | 1     | 0001       | 001    |
| lui   | 001111 |        | 00     | 1      | 00       | 1        | 0       | 0        | 0     | 0100       | 000    |
| addiu | 001001 |        | 00     | 1      | 00       | 1        | 0       | 0        | 1     | 0000       | 000    |
| jal   | 000011 |        | 10     | 0      | 10       | 1        | 0       | 0        | 0     | 0000       | 011    |
| jr    | 000000 | 001000 | 00     | 0      | 00       | 0        | 0       | 0        | 0     | 0000       | 100    |

+ `add`、`sub`还未考虑溢出
+ `addiu`并非是无符号，只是不考虑溢出；`addi`应实现考虑溢出

---

### 后续考量：

+ ALU中在增加一运算数C
+ ALU中实现溢出判断。
+ 增加ALU的功能(参考xc博客)
+ 考虑是否实现GRF在顶层的透明化（或者用更多的多路选择器与选择信号来指定操作寄存器）
+ EXT未封装且只有在ALU的imm里实现了选择EXT
+ 未实现\$gp、\$sp寄存器的初始化，同时缺少lo，hi寄存器
